(defpackage #:red7
  (:use #:CL))

(in-package #:red7)

(declaim (optimize (debug 2)))

(eval-when (:load-toplevel :compile-toplevel :execute)
  (defparameter *colors* '(red orange yellow green blue indigo violet)))

;; A card is an integer between 0 and 55 (inclusive). The low 3 bits
;; are the color, with a "0" being a dummy color that's not used in
;; any way. The next 3 bits are the card's numeric value - 1 (0-6).
(deftype card () '(mod 56))

;; An unordered collection of cards is represented as a 56-bit integer.
(deftype card-set () '(unsigned-byte 56))

(declaim (inline card-color))
(defun card-color (card)
  (declare (type card card))
  (ldb (byte 3 0) card))

(declaim (inline card-value))
(defun card-value (card)
  (declare (type card card))
  (1+ (ash card -3)))

(defstruct (deck (:constructor %make-deck))
  (cards (make-array 49 :element-type 'card)
         :type (simple-array card (49)))
  (size 0 :type (mod 50)))

(defstruct (player)
  (id 0 :type (mod 5))
  eliminated
  (hand nil :type card-set)
  (palette nil :type card-set)
  (score-cache (make-array 16) :type (simple-vector 16))
  (next-player nil :type (or null player)))

(defstruct (game)
  (players nil :type list)
  (current nil :type (or null player))
  (deck (make-deck) :type deck)
  (canvas nil :type list))

(defmethod print-object ((player player) stream)
  (print-unreadable-object (player stream :type 'player)
    (format stream ":ID ~A :HAND ~A :PALETTE ~A :NEXT-PLAYER ~A"
            (player-id player)
            (cards-to-list (player-hand player))
            (cards-to-list (player-palette player))
            (let ((next (player-next-player player)))
              (if next
                  (player-id next)
                  nil)))))

(defun card-label (card)
  (format nil "~A-~A"
          (nth (- 7 (card-color card)) *colors*)
          (card-value card)))

(defun make-deck ()
  (let ((deck (%make-deck)))
    (dotimes (value 7)
      (dotimes (color 7)
        (setf (aref (deck-cards deck) (deck-size deck))
              (logior (1+ color)
                      (ash value 3)))
        (incf (deck-size deck))))
    (shuffle-deck deck)
    deck))

(defun shuffle-deck (deck)
  (let ((size (deck-size deck)))
    (dotimes (i size)
      (rotatef (aref (deck-cards deck) i)
               (aref (deck-cards deck) (random size))))))

(defun draw-from-deck (deck)
  (aref (deck-cards deck) (decf (deck-size deck))))

(defun undo-draw (deck)
  (prog1
      (aref (deck-cards deck) (deck-size deck))
    (incf (deck-size deck))))

(declaim (inline remove-card))
(defun remove-card (card card-set)
  (declare (type card card)
           (type card-set card-set))
  (logandc2 card-set (ash 1 card)))

(declaim (inline add-card))
(defun add-card (card card-set)
  (declare (type card card)
           (type card-set card-set))
  (logior card-set (ash 1 card)))

(defun cards-to-list (card-set)
  (loop for i from 55 downto 0
        when (logbitp i card-set)
        collect (card-label i)))

(defun make-card-set (cards)
  (let ((set 0))
    (dolist (card cards)
      (setf set (logior set (ash 1 card))))
    set))

(defmacro do-cards ((card card-set) &body body)
  (let ((modified-card (gensym)))
    `(loop with ,modified-card of-type card-set = ,card-set
           until (zerop ,modified-card)
           for ,card = (1- (integer-length ,modified-card))
           do (setf (logbitp ,card ,modified-card) nil)
           do ,@body)))

(defun card-set-score (card-set rule)
  (declare (optimize speed)
           (card-set card-set))
  (labels ((score-for-mask (mask)
             (let ((matching-cards (logand card-set
                                           mask)))
               (let ((matching-cards (logcount matching-cards))
                     (best-matching-card (integer-length matching-cards)))
                 (+ best-matching-card (* 64 matching-cards)))))
           (red ()
             (integer-length card-set))
           (orange ()
             (loop for mask of-type card-set = #xff000000000000 then (ash mask -8)
                   repeat 7
                   maximize (score-for-mask mask)))
           (yellow ()
             (loop for mask of-type card-set = #x80808080808080 then (ash mask -1)
                   repeat 7
                   maximize (score-for-mask mask)))
           (green ()
             (score-for-mask #x00ff00ff00ff00))
           (blue ()
             (let* ((palette card-set)
                    (best-card (integer-length palette)))
               ;; OR all bytes into the lowest byte -> a bit will be set
               ;; for each color that's present.
               (setf palette (logior palette (ash palette -32)))
               (setf palette (logior palette (ash palette -16)))
               (setf palette (logior palette (ash palette -8)))
               (+ best-card
                  (* 64 (logcount (ldb (byte 8 0) palette))))))
           (indigo ()
             (let ((prev nil)
                   (current-run-score 0)
                   (best-score 0))
               (declare (type (unsigned-byte 16) current-run-score best-score))
               (do-cards (card card-set)
                 (cond ((not prev)
                        (setf current-run-score card)
                        (setf prev card))
                       ((= (card-value card) (card-value prev)))
                       ((= (card-value card) (1- (card-value prev)))
                        (incf current-run-score 64)
                        (setf prev card))
                       (t
                        (setf current-run-score card)
                        (setf prev card)))
                 (setf best-score (max best-score current-run-score)))
               best-score))
           (violet ()
             (score-for-mask #x00000000ffffff)))
    (declare (inline score-for-mask)
             (notinline red orange yellow green blue indigo violet))
    (ecase rule
      (7 (red))
      (6 (orange))
      (5 (yellow))
      (4 (green))
      (3 (blue))
      (2 (indigo))
      (1 (violet)))))

(defun player-score (player rule)
  (declare (optimize speed)
           (type (mod 8) rule))
  (let* ((palette (player-palette player))
         (cache (player-score-cache player))
         (cached-key (aref cache rule)))
    (if (eql cached-key palette)
        (aref cache (+ rule 8))
        (progn
          (setf (aref cache rule) palette)
          (setf (aref cache (+ rule 8))
                (card-set-score palette rule))))))


(defun who-is-winning (game rule)
  (declare (optimize speed))
  (let (;; Note: all scoring rules must score 0 when the palette doesn't match
        ;; at all.
        (best-score 0)
        best-player)
    ;; (format t "---~%canvas ~a~%" (when (game-canvas game)
    ;;                                (card-label (first (game-canvas game)))))
    (dolist (player (game-players game))
      (unless (player-eliminated player)
        (let ((score (player-score player rule)))
          (declare (fixnum score))
          ;; (format t "player ~a, palette ~a, score ~a~%"
          ;;         (player-id player)
          ;;         (cards-to-list (player-palette player))
          ;;         score)
          (when (> score best-score)
            (setf best-score score
                  best-player player)))))
    best-player))

(defun player-is-winning (player rule)
  (declare (optimize speed))
  (loop with orig-player = player
        with orig-score of-type fixnum = (player-score player rule)
        for player = (player-next-player orig-player) then (player-next-player player)
        until (eql player orig-player)
        do (when (>= (the fixnum (player-score player rule))
                     orig-score)
             (return-from player-is-winning nil)))
  t)

(deftype move () '(unsigned-byte 16))

(declaim (inline allocate-move))
(defun allocate-move (type card)
  (if card
      (ecase type
        (:play card)
        (:discard (logior 64 card)))
      0))

(declaim (inline merge-moves))
(defun merge-moves (first second)
  (if (zerop first)
      second
      (logior first (ash second 8))))

(declaim (inline reverse-move))
(defun reverse-move (move)
  (if (<= move 256)
      move
      (logior (ash (ldb (byte 8 0) move) 8)
              (ldb (byte 8 8) move))))

(defmacro do-moves (((kind card) moves) &body body)
  (let ((move (gensym))
        (moves-var (gensym)))
    `(loop for ,moves-var of-type move = ,moves then (ash ,moves-var -8)
           for ,move = (ldb (byte 8 0) ,moves-var)
           until (zerop ,moves-var)
           do (let ((,kind (if (> ,move 64)
                               :discard
                               :play))
                    (,card (ldb (byte 6 0) ,move)))
                ,@body))))

(defun valid-moves (current-rule player)
  (declare (optimize speed))
  (let ((valid-moves))
    (labels ((check-discard (play-card)
               (do-cards (discard-card (player-hand player))
                 (unless (or (eql play-card discard-card)
                             (and (eql current-rule (card-color discard-card))
                                  (>= (logcount (player-palette player))
                                      (card-value discard-card))))
                   (when (player-is-winning player (card-color discard-card))
                     (push (merge-moves (allocate-move :play play-card)
                                        (allocate-move :discard discard-card))
                           valid-moves)))))
             (check-plays ()
               (do-cards (play-card (player-hand player))
                 (setf (player-palette player)
                       (add-card play-card (player-palette player)))
                 (when (player-is-winning player current-rule)
                   (push (allocate-move :play play-card) valid-moves))
                 (check-discard play-card)
                 (setf (player-palette player)
                       (remove-card play-card (player-palette player))))))
      (check-plays)
      (check-discard nil))
    valid-moves))

(defun execute-move (game player move)
  (declare (optimize speed)
           (type move move))
  (do-moves ((kind card) move)
      ;; (when card
      ;;   (format t "  executing ~a ~a~%" kind (card-label card)))
      (when (eq kind :play)
        (setf (player-palette player)
              (add-card card (player-palette player)))
        (setf (player-hand player)
              (remove-card card (player-hand player))))
      (when (eq kind :discard)
        (push card (game-canvas game))
        (setf (player-hand player)
              (remove-card card (player-hand player)))
        (when (> (card-value card) (logcount (player-palette player)))
          (let ((draw (draw-from-deck (game-deck game))))
            ;; (format t "  gain ~a from discard~%" (card-label draw))
            (setf (player-hand player)
                  (add-card draw (player-hand player)))))))
  #+nil
  (assert (eq player (who-is-winning game))))

(defun undo-move (game player move)
  (declare (optimize speed)
           (type move move))
  (do-moves ((kind card) (reverse-move move))
    ;; (when card
    ;;   (format t "  undoing ~a ~a~%" kind (card-label card)))
    (when (eq kind :play)
      (setf (player-palette player)
            (remove-card card (player-palette player)))
      (setf (player-hand player)
            (add-card card (player-hand player))))
    (when (eq kind :discard)
      (let ((removed (pop (game-canvas game))))
        (assert (eql card removed)))
      (setf (player-hand player)
            (add-card card (player-hand player)))
      (when (> (card-value card) (logcount (player-palette player)))
        (let ((draw (undo-draw (game-deck game))))
          ;; (format t "  return ~a to deck~%" (card-label draw))
          (setf (player-hand player)
                (remove-card draw (player-hand player))))))))

(defun win-ratios (outcomes player-count)
  (let ((total-wins (reduce #'+ outcomes)))
    (loop for p below player-count
          collect (cons p
                        (/ (loop for i from p below (length outcomes) by player-count
                                 summing (aref outcomes i))
                           total-wins)))))

(defun print-outcomes (outcomes player-count)
  (let ((win-ratios (win-ratios outcomes player-count)))
    (dolist (record win-ratios)
      (destructuring-bind (id . win-ratio) record
        (format t "id: ~a, ~a%~%" id
                (* 100.0 win-ratio))))))

(defun play (player-count game-count)
  (declare (optimize speed)
           (type (unsigned-byte 32) game-count)
           (type (mod 5) player-count))
  (let ((cumulative-outcomes (make-array (* 50 player-count)
                                         :element-type '(unsigned-byte 62)
                                         :initial-element 0))
        (depth (make-array 50
                           :element-type '(unsigned-byte 62)
                           :initial-element 0))
        rows
        (lengths (make-array 100 :element-type '(unsigned-byte 62)))
        (actions 0))
    (dotimes (game-index game-count)
      (let* ((game (make-game))
             (outcomes (make-array (* 50 player-count)
                                   :element-type '(unsigned-byte 62)
                                   :initial-element 0))
             (deck (game-deck game)))
        (dotimes (i player-count)
          (let ((player (make-player :palette (make-card-set (list
                                                              (draw-from-deck deck)))
                                     :hand (make-card-set (loop repeat 7
                                                                collect (draw-from-deck deck))))))
            (push player (game-players game))))
        (mapcar (lambda (player next)
                  (setf (player-next-player player) next))
                (game-players game)
                (cdr (append (game-players game) (game-players game))))
        (let ((start-leader (who-is-winning game 7))
              (players-left player-count)
              (turns 0))
          (declare (type (unsigned-byte 60) actions players-left turns))
          (loop for player = start-leader then (player-next-player player)
                for id from 0 below player-count
                do (setf (player-id player) id))
          ;; (format t "starting player: ~a~%" (player-id start-leader))
          (labels ((advance-to-next-player (player)
                     (incf turns)
                     (dotimes (p (1- player-count))
                       (setf player (player-next-player player))
                       (unless (player-eliminated player)
                         (select-move player)
                         (return)))
                     (decf turns))
                   (eliminate-player (player)
                     ;; (format t "player ~a eliminated (canvas ~a)~%~a~%" *leader*
                     ;;         (card-label (first (game-canvas game)))
                     ;;         game)
                     (decf players-left)
                     (setf (player-eliminated player) t)
                     (after-eliminate player)
                     (incf players-left)
                     (setf (player-eliminated player) nil))
                   (after-eliminate (player)
                     (when (> players-left 1)
                       (advance-to-next-player player)
                       (return-from after-eliminate))
                     (let ((winner
                            (player-id (loop for p = player then (player-next-player p)
                                             unless (player-eliminated p)
                                             return p))))
                       (incf (aref outcomes
                                   (+ winner (* turns player-count))))
                       (when (zerop (logand actions #xffffff))
                         (progress-info))))
                   (progress-info ()
                     ;; (return-from play)
                     (format t "Match outcomes~%")
                     (print-outcomes outcomes player-count)
                     (format t "Cumulative outcomes~%")
                     (print-outcomes cumulative-outcomes player-count)
                     (format t "games: ~a/~a~%actions: ~a~%turns: ~a~%available moves: ~a~%"
                             (1+ game-index) game-count
                             actions depth lengths))
                   (select-move (player)
                     (let* ((current-rule (if (game-canvas game)
                                              (card-color (first (game-canvas game)))
                                              7))
                            (moves (valid-moves current-rule player))
                            (move-count (length moves)))
                       (declare (ignorable move-count))
                       ;; (format t "player ~a has ~d moves~%"
                       ;;         *leader* move-count)
                       (incf (aref lengths move-count))
                       (incf actions)
                       (incf (aref depth turns))
                       (if (not moves)
                           (eliminate-player player)
                           (if (<= move-count 1)
                               (dolist (move moves)
                                 (execute-selected-move player move))
                               (dotimes (i 1)
                                 (let ((move (nth (random move-count) moves)))
                                   (execute-selected-move player move)))))))
                   (execute-selected-move (player move)
                     (execute-move game player move)
                     (advance-to-next-player player)
                     (undo-move game player move)
                     nil))
            (dotimes (i 100000)
              (advance-to-next-player start-leader))
            (map-into cumulative-outcomes #'+ cumulative-outcomes outcomes)
            (push (win-ratios outcomes player-count) rows)
            (progress-info)))))
    rows))
